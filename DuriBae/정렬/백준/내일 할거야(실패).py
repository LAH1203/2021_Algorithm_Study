#n개 과제 목록. 과제 i는 di일이 걸리고, ti일까지 끝내야 한다.
#오늘이 0일이면 ti일이 끝나기 전에 제출. 한 번 시작하면 쉬지않고 진행.
#과제가 있을 때 연속으로 며칠동안 놀 수 있는가.
#입력 : 과제 개수 n, 과제를 나타내는 두 정수 di,ti 가 주어진다. 오늘은 0일. 오늘은 아무것도 안해도 된다
#출력 : 내일부터 최대 며칠 동안 놀 수 있는지 출력한다. 0이면 내일 과제를 해야 하고, 1이면 모레에 과제를 해야 한다.

#제출일에서 걸리는 날짜를 빼면 놀 수 있는 날짜
#6일 12일 7일

#제출 기한이 짧은 게 있으면 그것부터 삭제
#13-8 = 5, 13-10=3, 10-8=2
#제출 기한 텀과 과제 진행일 비교
#5>1 3>1 2<3
#그냥 배열에 넣어서 인덱스만큼 숫자 채우면 안되나.
#채운 다음에 연속되면 비교용 배열에 집어넣고 길이 긴 거 고르면 되잖아.

n = int(input())
d = []
t = []
for __ in range(n):
    data = input().split()
    d.append(int(data[0]))
    t.append(int(data[1]))
    

#과제 시작 날짜 = 기한에서 과제 진행일 뺀 거.
#6,12,7 시작날짜 열거하기 => 6,7,12
#시작날짜 사이에 쉴 수 있음.
#당일 과제를 하냐 안하냐가 애매하다. 최대한 미룬다고 했으니까 당일 하는 걸 가정.
# 그러면 시작 날짜 : 7,13,8 / 겹치면 뒤로 빼야 함.

count = [0]*(max(t)+1)

for i in range(len(t)-1,-1,-1):
    c=0
    for j in range(t[i],t[i]-d[i],-1):
        if(count[j]>0):
            count[t[i]-d[i]]+=1
        else:
            count[j]+=1
        
        c+=1

day = 0
result = []
for k in range(1,len(count)):
    if(count[k]==0):
        day+=1
    if(count[k]==1):
        result.append(day)
        day=0

print(max(result))